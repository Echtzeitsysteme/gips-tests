package "gipsl.edf"
import "platform:/resource/gips.edf.edfmodel/model/Edfmodel.ecore"

config {  
	solver := GUROBI [home:="fu", license:="bar"];
	timeLimit := true [value := 60.0];
	randomSeed := true [value := 0];
	presolve := true;
	debugOutput := true;
}

rule runTaskInSlot {
	root: Root {
		-tasks -> t
		-slots -> s
	}
	
	t: Task {
		++ -runningon -> s
	}
	
	s: Slot
	
	# t.^deadline >= s.^index
}

mapping t2s with runTaskInSlot;

// Every task must be mapped n times (according to its duration)
constraint -> class::Task {
	mappings.t2s->filter(m | m.nodes().t == self)->count() == self.duration
}

// There must be at most one mapping per slot
constraint -> class::Slot {
	mappings.t2s->filter(m | m.nodes().s == self)->count() <= 1
}

//// TODO: Objective: Per slot use the non-mapped task with the earliest deadline
//objective edf -> mapping::t2s {
//	-1 * (self.nodes().s.index - self.nodes().t.deadline)
//}

//// Objective EDF: Use the task with the earliest deadline
//objective edf -> mapping::t2s {
//	self.nodes().t.deadline
//}

objective edf -> class::Slot {
	mappings.t2s->filter(m | m.nodes().s == self)->sum(m | m.nodes().t.deadline)
}

global objective : min {
	edf
}
