package "gips.minvariable"
import "platform:/resource/gips.minvariablemodel/model/Minvariablemodel.ecore"

config {  
	solver := GUROBI;
	timeLimit := true [value := 10.0];
	randomSeed := true [value := 0];
	presolve := true;
	debugOutput := true;
	lpOutput := true [path := "./problem.lp"];
}

//
// GT
//

rule selectNode {
	root : Root {
		- nodess -> n
	}
	
	n : Node {
		.selected := true
	}	
}

pattern findNodeContextCombination {
	root : Root {
		- nodess -> n
		- contextNodes -> c
	}
	
	n : Node
	c : Context
}

pattern findRoot {
	root : Root
}

pattern findSecondarySelectedNode {
	root : Root {
		- nodess -> n
	}
	
	n : Node
	
	# n.valueSecondary >= 1
}

pattern findSecondaryNotSelectedNode {
	root : Root {
		- nodess -> n
	}
	
	n : Node
	
	# n.valueSecondary == 0
}

//
// GIPSL
//

mapping select to selectNode {
	var z : EBoolean
};

mapping minimum to findRoot {
	var minimum : EInt
};

//constraint {
//	mappings.select->sum(element.value)
//	==
//	patterns.findSecondarySelectedNode->count()
//}

constraint with findSecondarySelectedNode {
	mappings.select->filter(element.nodes.n == context.nodes.n)->sum(element.value)
	==
	1
}
constraint with findSecondaryNotSelectedNode {
	mappings.select->filter(element.nodes.n == context.nodes.n)->sum(element.value)
	==
	0
}

//// This constraint should not be necessary
//constraint with minimum {
//	context.variables.minimum >= 0
//}

// Min constraint is complicated
//
// Q <= a * R_i
constraint with select {
//	[
//		mappings.select->filter( //
//			element.nodes.n == context.nodes.n //
//			& element.nodes.root == context.nodes.root
//		)->sum(element.value) == 1
//	]
//	=>
//	[
		mappings.minimum->sum(element.variables.minimum)
		<= context.nodes.n.valueConstant * context.value
		+ 1000 * (1 - context.value)
//	]
}

// Q >= a * R_i - M(1 - z_i)
constraint with select {
//	[
//		mappings.select->filter( //
//			element.nodes.n == context.nodes.n //
//			& element.nodes.root == context.nodes.root
//		)->sum(element.value) == 1
//	]
//	=>
//	[
		mappings.minimum->sum(element.variables.minimum)
		>= context.nodes.n.valueConstant * context.value
		- 1000 * (1 - context.variables.z)
//		- 1000 * (1 - context.value)
//	]
}

// sum_i(z_i) == 1
// TODO: this generates broken code
//constraint {
//	mappings.select->sum(element.value) >= 1
//	=>
//	mappings.select->sum(element.variables.z) == 1
//}
constraint with findRoot {
//constraint {
	mappings.select->sum(element.value) >= 1
	=>
	mappings.select->sum(element.variables.z) == 1
}

constraint with findRoot {
	mappings.select->sum(element.value) == 0
	=>
	mappings.minimum->sum(element.variables.minimum) == 0
}

// z must only be set if mapping was selected
constraint with select {
	context.value >= context.variables.z
}

// Objective: maximize the number of selected mappings
function select with select {
	context.value
}

objective : max {
	0
	+ functions.select
}
