package "gips.minvariable"
import "platform:/resource/gips.minvariablemodel/model/Minvariablemodel.ecore"

config {  
	solver := GUROBI;
	timeLimit := true [value := 10.0];
	randomSeed := true [value := 0];
	presolve := true;
	debugOutput := true;
	lpOutput := true [path := "./problem.lp"];
}

//
// GT
//

rule selectNode {
	root : Root {
		- nodess -> n
	}
	
	n : Node {
		.selected := true
	}	
}

pattern findNodeContextCombination {
	root : Root {
		- nodess -> n
		- contextNodes -> c
	}
	
	n : Node
	c : Context
}

pattern findRoot {
	root : Root
}

pattern findSecondarySelectedNode {
	root : Root {
		- nodess -> n
	}
	
	n : Node
	
	# n.valueSecondary >= 1
}

//
// GIPSL
//

mapping select to selectNode {
	var z : EBoolean
};

mapping minimum to findRoot {
	var minimum : EInt
};

constraint {
	mappings.select->sum(element.value)
	==
	patterns.findSecondarySelectedNode->count()
}

// This constraint should not be necessary
constraint with minimum {
	context.variables.minimum >= 0
}

// Min constraint is complicated
//
// Q <= a * R_i
constraint with select {
//	[
//		mappings.select->filter( //
//			element.nodes.n == context.nodes.n //
//			& element.nodes.root == context.nodes.root
//		)->sum(element.value) == 1
//	]
//	=>
	[
		mappings.minimum->sum(element.variables.minimum)
		<= context.nodes.n.valueConstant * context.value
	]
}

// Q >= a * R_i - M(1 - z_i)
constraint with select {
//	[
//		mappings.select->filter( //
//			element.nodes.n == context.nodes.n //
//			& element.nodes.root == context.nodes.root
//		)->sum(element.value) == 1
//	]
//	=>
	[
		mappings.minimum->sum(element.variables.minimum)
		>= context.nodes.n.valueConstant * context.value
		- 1000 * (1 - context.variables.z)
	]
}

// sum_i(z_i) == 1
constraint {
	mappings.select->sum(element.variables.z) == 1
}

// Objective: maximize the number of selected mappings
function select with select {
	context.value
}

objective : max {
	0
	+ functions.select
}
